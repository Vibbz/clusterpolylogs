import numpy as np
from sympy import simplify, Symbol
from random import random
from sys import stdout
from time import time
from functions import overprint, main, numerical_test
from quivers import generate_quiver
from itertools import combinations
from wedge import basis_of_CL2, expected_dimension_of_cln_gr2m
import sys
import pickle
from menu import menu
from wedge import mathematica_test

mathematica_test()

try:
  file1=open('result_number.pk','x')
  file1.close()
except:
  pass

try:
  file2=open('resultsdict.pk','x')
  file2.close()
except:
  pass

try:
 file3=open('cl2_dictionary.pk','x')
 file3.close()
except:
 pass



#Background:
cluster_info_dump='''This program is designed to find x-coordinates and a-coordinates of a cluster algebra. k

A cluster algebra is generated combinatorially from a quiver, a directed graph with labeled vertices 1,..n that has no 1- or 2-cycles, together with a "cluster" or an n-tuple decorating the cluster (i.e., a=(a_1,...a_n) is a cluster with each a_i associated to vertex i). We call the pair of a quiver and cluster a seed. 

A mutation of a seed at a vertex, k, involves the following steps:
1. For each pair of directed edges of the form i->k, k->j, create an edge i->j.
2. Reverse the direction of all arrows with source or target k.
3. Remove all 2-cycles
4. Relabel vertex k, sending a_k to a_k'=(1/a_k)*(product in + product out) where product in/out denotes the product of all vertices with edges going into or out of k respectively.

An example: Consider the seed x->y mutated at the vertex labeled x. Then we obtain (1+y)/x <- y.

A vertex in a seed is either mutable, meaning it is permissable to perform a mutation at that vertex, or it is frozen and a mutation cannot be performed at that vertex. Edges in/out of frozen vertices can still be changed by mutations at other vertices.

Two seeds are called mutation equivalent if there exists a sequence of mutations at mutable vertices yielding transforming one to the other. Given a seed, S, the cluster algebra is the polynomial ring over the rationals generated by all the a-coordinates appearing in mutation-equivalent seeds to S.

An x-coordinate of a vertex in a seed is simply the ratio (product out)/(product in). All the x-coordinates of a seed S are all X-coordinates appearing in 

We consider some quivers to have canonical vertex sets, in particular the associated quivers to Gr(p,n). (The Grassmannian)

The program works by iteratively applying random mutations and adding the newfound coordinates to a set. For the grassmanians, an additional numerical measure is added to check for duplicates modulo plucker relations.

Here we consider quivers as nxn skew-symmetric matrices where the entries e_ij correspond to the number of edges going from vertex i into vertex j, with the number considered negative if the direction is reversed. Mutation is described on quivers in this manner in equation (1.1) at the bottom of the first page on Zickert's notes on Cluster Algebras.

Created by Etienne Phillips at the University of Maryland Pure and Applied Mathematics REU 2023 working under Dr. Christian Zickert.
'''
a12=Symbol('a12')
a13=Symbol('a13')
a14=Symbol('a14')
a15=Symbol('a15')
a16=Symbol('a16')
a26=Symbol('a26')
a36=Symbol('a36')
a46=Symbol('a46')
a56=Symbol('a56')
a23=Symbol('a23')
a24=Symbol('a24')
a25=Symbol('a25')
a34=Symbol('a34')
a35=Symbol('a34')
a45=Symbol('a45')


try: 
  with open('result_number.pk','rb') as fi:
    result_number= pickle.load(fi)
    print(f'\nSuccessfully retrieved result_number: {result_number}.\n')
except Exception as exc:
  result_number=0
  print('\nCould not retrieve result_number, setting result_number=0.\n')
  print(exc)

try:  
  with open('resultsdict.pk','rb') as fi:
    results_dictionary=pickle.load(fi)
    print(f'\nSuccessfully loaded results_dictionary with {len(results_dictionary.keys())} results.\n')
except Exception as exc:
  results_dictionary={'x1x,gr26':({(a16*a34/(a13*a46), a14*a36/(a13*a46)), (a13*a46/(a16*a34), a14*a36/(a16*a34)), (a13*a45/(a15*a34), a14*a35/(a15*a34)), (a25*a34/(a23*a45), a24*a35/(a23*a45)), (a12*a45/(a15*a24), a14*a25/(a15*a24)), (a36*a45/(a34*a56), a35*a46/(a34*a56)), (a15*a24/(a12*a45), a14*a25/(a12*a45)), (a16*a45/(a14*a56), a15*a46/(a14*a56)), (a13*a56/(a16*a35), a15*a36/(a16*a35)), (a12*a46/(a16*a24), a14*a26/(a16*a24)), (a26*a34/(a23*a46), a24*a36/(a23*a46)), (a24*a56/(a26*a45), a25*a46/(a26*a45)), (a14*a56/(a16*a45), a15*a46/(a16*a45)), (a16*a23/(a12*a36), a13*a26/(a12*a36)), (a14*a23/(a12*a34), a13*a24/(a12*a34)), (a12*a35/(a15*a23), a13*a25/(a15*a23)), (a12*a34/(a14*a23), a13*a24/(a14*a23)), (a15*a23/(a12*a35), a13*a25/(a12*a35)), (a12*a36/(a16*a23), a13*a26/(a16*a23)), (a23*a46/(a26*a34), a24*a36/(a26*a34)), (a15*a34/(a13*a45), a14*a35/(a13*a45)), (a16*a25/(a12*a56), a15*a26/(a12*a56)), (a23*a45/(a25*a34), a24*a35/(a25*a34)), (a26*a35/(a23*a56), a25*a36/(a23*a56)), (a12*a56/(a16*a25), a15*a26/(a16*a25)), (a26*a45/(a24*a56), a25*a46/(a24*a56)), (a34*a56/(a36*a45), a35*a46/(a36*a45)), (a16*a35/(a13*a56), a15*a36/(a13*a56)), (a16*a24/(a12*a46), a14*a26/(a12*a46)), (a23*a56/(a26*a35), a25*a36/(a26*a35))},['a26', 'a25', 'a24', 'a23', 'a16', 'a56', 'a45', 'a34', 'a12', 'a36', 'a35', 'a14', 'a15', 'a46', 'a13'],{}), 'cl,gr26':({frozenset({a35, a56, a16, a34, a23, a45, a26, a25, a12}), frozenset({a24, a56, a34, a16, a23, a45, a26, a46, a12}), frozenset({a56, a34, a16, a23, a45, a46, a36, a12, a13}), frozenset({a56, a34, a16, a23, a45, a26, a46, a36, a12}), frozenset({a24, a56, a34, a16, a23, a45, a15, a14, a12}), frozenset({a24, a56, a34, a16, a23, a45, a26, a25, a12}), frozenset({a24, a56, a34, 
a16, a23, a45, a25, a15, a12}), frozenset({a35, a56, a16, a34, a23, a45, a25, a15, a12}), frozenset({a35, a56, a16, a34, a23, a45, a15, a12, a13}), frozenset({a56, a34, a16, a23, a45, a46, a14, a12, a13}), frozenset({a35, a56, a16, a34, a23, a45, a26, a36, a12}), frozenset({a35, a56, a16, a34, a23, a45, a36, a12, a13}), frozenset({a24, a56, a34, a16, a23, a45, a46, a14, a12}), frozenset({a56, a34, a16, a23, a45, a15, a14, a12, a13})},['a26', 'a25', 'a24', 'a23', 'a16', 'a56', 'a45', 'a34', 'a12', 'a36', 'a35', 'a14', 'a15', 'a46', 'a13'],{})}
  print('\nCould not retrieve results_dictionary, setting to default.\n')
  print(exc)

try: 
  with open('cl2_dictionary.pk','rb') as fi:
      cl2_dictionary= pickle.load(fi)
      print(f'\nSuccessfully retrieved {len(cl2_dictionary)} saved bases of CL2.\nThe keys are: {cl2_dictionary.keys()}')
except Exception as exc:
  cl2_dictionary={}
  print('\nCould not retrieve cl2_dictionary, setting empty dict.\n')
  print(exc)

print('\n')




###########################
# Main program code block #
###########################

print('''This program works by doing some number of random mutations repeatedly for some number of iterations. The program can be interrupted during computations with keyboard interrupt to print the result so far.\n''')
print('NOTE: Having Mathematica installed is reqiured for some features to work properly.')
print(f'''Please choose from the following options: \n 
 info: returns information about this program and Cluster Algebras. \n
 co: to compute coordinates or clusters of a cluster algebra. \n
 qu: to find all quivers of a cluster algebra. \n
 keys: print all keys for saved results, enter a key to print associated result. \n''')
while True:

  menus=menu(cluster_info_dump,results_dictionary,cl2_dictionary)
  do_find_x_coords=menus[0]
  do_find_a_coords=menus[1]
  do_find_clusters=menus[3]
  do_find_x1x=menus[2]

  skip_input_1=menus[7]
  skip_input_2=menus[8]
  skip_input_3=menus[9]


  option1=menus[12]
  test_mode=menus[4]
  skip_numeric_test_error=menus[6]
  test_dupes=menus[5]


  m=menus[11]

  muted=menus[10]

  num_of_mutations=menus[13]
  quiver_data=menus[14]
  quiver_data_s=menus[15]
  
  find_coords=menus[16]

  iteration_limit=menus[17]

  if iteration_limit=='':
    iteration_limit=0
  iteration_limit=int(iteration_limit)
  
  keep_looping=True
  
  universal_start_time=time()
  
  final_result=set()
  iteration=0

  new_coordinate_number=1
  
  try:
    if muted:
      print('Computing X-coordinates...')
    #overprint(f'iteration: {iteration} / {iteration_limit}')
    last_coordinates_found=1
    empty_iterations=0
    
    
    if skip_input_3:
      quiver_data_s=f'gr2{m}'
      quiver_data=generate_quiver(quiver_data_s)
      m+=1
    
    while keep_looping==True:
      iteration+=1

      if last_coordinates_found==0:
        empty_iterations+=1
      
      if test_mode==True:
        print('\nGeneral test mode output...')
        print(f'Option 1: {option1}')
        print('Number of mutations: {0}'.format(num_of_mutations))
        print('Quiver: ',quiver_data[0])
        print('Vertices: ',quiver_data[1])
        print('Mutables: ',quiver_data[2])
        print('Numerical vertices: ', quiver_data[3])
        print()
      
      ####################### 
      #Actually calling main#
      new_results=main(option1,num_of_mutations,[quiver_data[0].copy(),quiver_data[1].copy(),quiver_data[2],quiver_data[3].copy()],do_find_x_coords,do_find_a_coords,do_find_clusters,do_find_x1x,new_coordinate_number,test_mode,muted)

      quiver_data=list(quiver_data)      
      quiver_data[1]=new_results[2]
      quiver_data[3]=new_results[3]
      quiver_data=tuple(quiver_data)
      
      new_coordinate_number=new_results[1]
      
      old_length=len(final_result)

      
      #To prevent infinite runtime after all coordinates are found.
      if last_coordinates_found>0:
        total_duplicates=0
        empty_iterations=0
      
      for co in new_results[0]:
        final_result.add(co)
      
      if option1=='gr':
        #Numeric test for equality modulo plucker relations
        if test_dupes==True:
          temp_object=numerical_test(iteration,quiver_data,final_result,do_find_clusters,0,old_length,skip_numeric_test_error,find_coords,keep_looping)
          final_result=temp_object[0]
          last_coordinates_found=temp_object[1]
          keep_looping=temp_object[2]
        else:
          if muted==False:
            overprint(f'{iteration}: Found {-old_length+len(final_result)} new {find_coords.capitalize()}-coordinates. Total: {len(final_result)}\n')

          last_coordinates_found= len(final_result)-old_length
        
          
      if option1=='qu':
        overprint(f'\n{1}: Found {len(final_result)} total quivers.\n')

      #Stops program if too many consecutive duplicates are found.
      if last_coordinates_found==0 and total_duplicates>50 and muted==False:
        overprint(f'\nFound {total_duplicates}/500 consecutive duplicates. \n\n')
        if total_duplicates>=500:
          print('Stopping...')
          raise KeyboardInterrupt

      if last_coordinates_found==0 and empty_iterations>10 and muted==False:
        overprint(f'\nCompleted {empty_iterations}/{len(final_result)//2} consecutive empty iterations. \n\n')
        if empty_iterations>=len(final_result)//2:
          print('Stopping...')
          raise KeyboardInterrupt
      
      if iteration_limit!=0:
        keep_looping= iteration < iteration_limit

  except KeyboardInterrupt:
    pass
  

  if option1=='gr' and test_mode==True:
    try:
      option4=input(f'Enter "s" to simplify results or press enter to skip: ')
      if option4=='s':
        newresult=[]
        time_to_simplify=time()
        for i,x in enumerate(final_result):
          overprint(f'Simplifying element {i} / {len(final_result)}')
          newresult+=[simplify(x)]
        final_result=newresult
        print('Time to simplify: ',time()-time_to_simplify)
    except:
      pass
      
  #Test mode stuff
  if option1=='gr' and test_mode==True:  
    option3=input(f'Enter "t" to test equivalency among {find_coords}-coordinates symbolically: ')
    if option3=='t':
          final_result=list(final_result)
          #print(final_result[len(final_result)-1])
          #Symbolic test for sameness
          to_remove=set()
          for i in range(len(final_result)-1):
            for j in range(i+1,len(final_result)-1):
              overprint('Checking equivalence of {0},{1}    '.format(i,j))
              same_test=simplify(final_result[i]-final_result[j])
              if same_test==0:
                print('\nFound equivalence at {0},{1}'.format(i,j))
                if i!=j:
                  print('Found equivalence between expr at position {0} and expr at position {1}'.format(i,j))
                  to_remove.add(i)
          for i, index in enumerate(to_remove):
            final_result.pop(index - i)
          final_result=set(final_result) 
          print(final_result)
          stdout.write('\r'+' '*20)


  ######################################################


  result_number+=1
  new_result_key=f'{find_coords},'+f'{quiver_data_s},'+f'{result_number}'
  results_dictionary[new_result_key]=(final_result,new_results[2],new_results[4])

  if not skip_input_1:
    print('\n\nResult: \n', final_result, f'\n\nNew variables: {new_results[4],len(new_results[4])}', f'\n\nFinal result key: {new_result_key} \n\nNumber found: {len(final_result)}')
    print('\nTotal computation time: ', time()-universal_start_time)
    print('\n Running again.')

    if input('Enter "s" to save result: ')=='s':
      with open('resultsdict.pk','wb') as fi1:
        pickle.dump(results_dictionary,fi1)

      with open('result_number.pk','wb') as fi2:
        pickle.dump(result_number,fi2)

  else:
    display_result=list(final_result)
    print('Computing CL2...\n')
    basis_and_dim=basis_of_CL2(display_result,quiver_data[1])  
    print(f'Computed dimension of CL2({quiver_data_s}): ', basis_and_dim[1])
    print('Expected dimension: ',expected_dimension_of_cln_gr2m(2,m-1))
    print('\n')
    option1='gr'

  