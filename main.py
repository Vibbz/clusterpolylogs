import numpy as np
from sympy import *
from random import randint
from random import random
from math import isclose
from sys import stdout
from time import time, sleep
from functions import mutation, quiver_mutations, coordinates, main
from quivers import generate_quiver

#Background:
'''This program is designed to find x-coordinates and a-coordinates of a cluster algebra. 

A cluster algebra is generated combinatorially from a quiver, a directed graph with labeled vertices 1,..n that has no 1- or 2-cycles, together with a "cluster" or an n-tuple decorating the cluster (i.e., a=(a_1,...a_n) is a cluster with each a_i associated to vertex i). We call the pair of a quiver and cluster a seed. 

A mutation of a seed at a vertex, k, involves the following steps:
1. For each pair of directed edges of the form i->k, k->j, create an edge i->j.
2. Reverse the direction of all arrows with source or target k.
3. Remove all 2-cycles
4. Relabel vertex k, sending a_k to a_k'=(1/a_k)*(product in + product out) where product in/out denotes the product of all vertices with edges going into or out of k respectively.

An example: Consider the seed x->y mutated at the vertex labeled x. Then we obtain (1+y)/x <- y.

A vertex in a seed is either mutable, meaning it is permissable to perform a mutation at that vertex, or it is frozen and a mutation cannot be performed at that vertex. Edges in/out of frozen vertices can still be changed by mutations at other vertices.

Two seeds are called mutation equivalent if there exists a sequence of mutations at mutable vertices yielding transforming one to the other. Given a seed, S, the cluster algebra is the polynomial ring over the rationals generated by all the a-coordinates appearing in mutation-equivalent seeds to S.

An x-coordinate of a vertex in a seed is simply the ratio (product out)/(product in). All the x-coordinates of a seed S are all X-coordinates appearing in 

We consider some quivers to have canonical vertex sets, in particular the associated quivers to Gr(p,n). (The Grassmannian)

The program works by iteratively applying random mutations and adding the newfound coordinates to a set. For the grassmanians, an additional numerical measure is added to check for duplicates modulo plucker relations.



Here we consider quivers as nxn skew-symmetric matrices where the entries e_ij correspond to the number of edges going from vertex i into vertex j, with the number considered negative if the direction is reversed. Mutation is described on quivers in this manner in equation (1.1) at the bottom of the first page on Zickert's notes on Cluster Algebras.
'''

#Defining gr(3,6) and codifying plucker relations

gr_36_quiver=np.array(
  [[0,1,1,-1,-1,0,0,0,0,0],
   [-1,0,0,1,0,1,-1,0,0,0],
   [-1,0,0,1,0,0,0,1,-1,0],
   [1,-1,-1,0,0,0,1,0,1,-1],
   [1,0,0,0,0,0,0,0,0,0],
   [0,-1,0,0,0,0,0,0,0,0],
   [0,1,0,-1,0,0,0,0,0,0],
   [0,0,-1,0,0,0,0,0,0,0],
   [0,0,1,-1,0,0,0,0,0,0],
   [0,0,0,1,0,0,0,0,0,0] ]
)
gr_36_vertices=['a236','a235','a136','a356','a123','a234','a345','a126','a156','a456']

gr_36_vertices_s=[Symbol(x) for x in gr_36_vertices]

#This is the matrix from which the plucker relations will be evaluated
#dummy_matrix=np.array([[1,2,3,4,5,6],[7,8,9,10,11,12],[13,14,16,17,18,19]])

dummy_matrix=np.array([[n+6*i+random() for n in range(6)] for i in range(3)])


#These are the associated nubmers to each vertex as listed above
gr_36_vertices_num=[np.linalg.det(np.array([ [row[int(i)-1] for i in list(plucker[1:])] for row in dummy_matrix ] )) for plucker in gr_36_vertices]


#Later, I'll make code that actually just generates this stuff in general.

#Live prints to console
def overprint(s):
  stdout.write(f'\r{s}')
  stdout.flush()


# Below is the actual program



###########################
# Main program code block #
###########################
print('''This program works by doing some number of random mutations repeatedly for some number of iterations. The program can be interrupted at any time with keyboard interrupt to print the result so far.  \n
Enter "co" to compute coordinates. \n
Enter "qu" to compute quivers resulting from mutations. \n
Enter "test" to enter test mode (not useful). \n''')

while True:
  option1=''
  test_mode=False
  while option1 not in ['gr','qu']:
    option1=input('Option: ')
    if option1=='test':
      test_mode=True
      print('Test mode enabled.')
    if option1=='co':
      option1='gr'
  
  quiver_data_s=input('Enter the quiver to use.\n gr36 uses the quiver for gr(3,6) with plucker coordinate vertices. \n gr2n uses the quiver for gr(2,n) with plucker coordinate vertices. \n ex2 uses the quiver 1->2 with default vertex labeling. \n ex3 uses the quiver 1->2->3 with default vertex labeling. \n Enter: ')
  quiver_data=generate_quiver(quiver_data_s)
  
  if option1=='gr':
    find_coords=input('Enter "x" to find X-coords, "a" to find A-coords, or "cl" to find all the clusters: ')
    if find_coords=="x":
      do_find_x_coords=True
      do_find_a_coords=False
      do_find_clusters=False
    elif find_coords=='a':
      do_find_a_coords=True
      do_find_x_coords=False
      do_find_clusters=False
    elif find_coords=="cl":
      do_find_clusters=True
    else:
      do_find_clusters=False
      do_find_a_coords=False
      do_find_x_coords=False
  else:
    do_find_a_coords=False
    do_find_x_coords=False
    do_find_clusters=False
  
  num_of_mutations=int(input('Enter the number of random mutations (not recommended to be larger than 20): '))
  iteration_limit=input('Enter the iteration limit or leave blank or enter 0 to iterate forever: ')
  
  if iteration_limit=='':
    iteration_limit=0
  iteration_limit=int(iteration_limit)
  
  keep_looping=True
  
  universal_start_time=time()
  
  final_result=set()
  iter=0
  
  try:
    while keep_looping==True:
      iter+=1

      if test_mode==True:
        print('\n General test mode output...')
        print(f'Option 1: {option1}')
        print('Number of mutations: {0}'.format(num_of_mutations))
        print('Quiver: ',quiver_data[0])
        print('Vertices: ',quiver_data[1])
        print('Mutables: ',quiver_data[2])
        print('Numerical vertices: ', quiver_data[3])
        print()

      
      ####################### 
      #Actually calling main#
      new_results=main(option1,num_of_mutations,[quiver_data[0].copy(),quiver_data[1].copy(),quiver_data[2],quiver_data[3].copy()],do_find_x_coords,do_find_a_coords,do_find_clusters,test_mode)
      
      old_length=len(final_result)
      
      for co in new_results:
        final_result.add(co)
      
      if option1=='gr':
        #Numeric test for equality modulo plucker relations
        #if statement is standin
        
        vertices_numerical=quiver_data[3].copy()
        vertices=[Symbol(x) for x in quiver_data[1]]

        
        if True==True:
          try:
            to_remove=[]
            pairs_of_dupes_found=0
            
            evals_plucker=[expr.subs([z for z in zip(vertices,vertices_numerical)]) for expr in final_result]
            
            for j in range(len(evals_plucker)):
              for i in range(j,len(evals_plucker)):
                  if j!=i:
                    if isclose(evals_plucker[i],evals_plucker[j]):
                      pairs_of_dupes_found+=1
  
                      #Testmode information
                      #if test_mode==True:
                      #  print('\n Test mode output, finding duplicates: \n', i, j, list(final_result)[i],list(final_result)[j], '\n', list(final_result)[i].subs([z for z in zip(vertices,vertices_numerical)]), list(final_result)[j].subs([z for z in zip(vertices,vertices_numerical)]),evals_plucker[i],evals_plucker[j])
                      #####################
                      to_remove+=[list(final_result)[j]]
  
            if pairs_of_dupes_found==len(to_remove) and test_mode==True:
              print('Test dupes = amt removed passed')
            elif test_mode==True:
              print('Test dupes = amt rmoved failed', pairs_of_dupes_found, len(to_remove))

            for x in to_remove:
              final_result.remove(x)
            final_result=set(final_result)
          except:
            print('\n Error in numeric test. Maybe vertices are not plucker coordinates.  \n')
            pass
            
          overprint(f'\n{iter}: Removed {len(to_remove)} duplicates. Found {-old_length+len(final_result)} new {find_coords.capitalize()}-coordinates. Found {len(final_result)} total {find_coords}-coordinates.\n')
          
        else:
          overprint(f'\n {iter}: Found {len(final_result)-old_length} new {find_coords.capitalize()}-coordinates, {len(final_result)} total {find_coords.capitalize()}-coordinates. \n')
          
        if option1=='qu':
          overprint(f'\n{1}: Found {len(final_result)} total quivers.\n')
      
      if iteration_limit!=0:
        keep_looping= iter<iteration_limit
  except KeyboardInterrupt:
    pass
  
  
  #Test sameness of coordinates
  if option1=='gr':  
    option3=input(f'Enter "t" to test equivalency among {find_coords}-coordinates symbolically: ')
    if option3=='t':
          final_result=list(final_result)
          #print(final_result[len(final_result)-1])
          #Symbolic test for sameness
          to_remove=set()
          for i in range(len(final_result)-1):
            for j in range(i+1,len(final_result)-1):
              overprint('Checking equivalence of {0},{1}    '.format(i,j))
              same_test=simplify(final_result[i]-final_result[j])
              if same_test==0:
                print('\nFound equivalence at {0},{1}'.format(i,j))
                if i!=j:
                  print('Found equivalence between expr at position {0} and expr at position {1}'.format(i,j))
                  to_remove.add(i)
          for i, index in enumerate(to_remove):
            final_result.pop(index - i)
          final_result=set(final_result) 
          print(final_result)
          #print('Time for iteration:', time()-start_time)
          stdout.write('\r'+' '*20)

  
  print('\n\nFinal result: \n', final_result, '\n Number found: ',len(final_result))
  print('\nTotal computation time: ', time()-universal_start_time)
  
  
  
  if option1=='qu':
    if test_mode==True:
      test='Passed'
      print('Test skew-symmetry: ')
      e=set()
      for x in final_result:
        x=list(list(t) for t in x)
        y=x.pop(-1)
        x=np.asarray(x[0])
        skewtranspose=-np.transpose(x)
        comparison=x==skewtranspose
        if not comparison.any():
          print(False)
          test='Failed'
        print(x,'\n','Mutations: ',y)
      print('\n',test)
  
  print('\n Run again:')

